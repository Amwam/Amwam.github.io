<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="manifest" href="manifest.json"/><title>Using React with Web Components<!-- --> | AMWAM - Amit Shah</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/938795f617db5085.css" as="style"/><link rel="stylesheet" href="/_next/static/css/938795f617db5085.css" data-n-g=""/><link rel="preload" href="/_next/static/css/84fcc0fe545abc91.css" as="style"/><link rel="stylesheet" href="/_next/static/css/84fcc0fe545abc91.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-cda2f1305c3d9424.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c7a57f1f8cc48b43.js" defer=""></script><script src="/_next/static/chunks/130-e012ff4e0435244f.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-af074a360fe0c7d6.js" defer=""></script><script src="/_next/static/KBWOP7REuQKajdISRRdU8/_buildManifest.js" defer=""></script><script src="/_next/static/KBWOP7REuQKajdISRRdU8/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="_app_container__HJghf"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-9977N7FRG8"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag(&#x27;js&#x27;, new Date());

          gtag(&#x27;config&#x27;, &#x27;G-9977N7FRG8&#x27;);
        </script><div id="Navigation_nav-bar__qBvYL" role="navigation"><img id="Navigation_nav-display-picture__z_2_S" src="/images/me.200.png" alt="Me (Amit)" loading="lazy"/><div id="Navigation_name__xoUmt">Amit Shah</div><div id="Navigation_nav-links__c1Wi_"><div class="Navigation_nav-link__1_q_g"><a href="/">Home</a></div><div class="Navigation_nav-link__1_q_g"><a href="/about">About</a></div><div class="Navigation_nav-link__1_q_g"><a href="/blog">Blog</a></div><div class="Navigation_nav-link__1_q_g"><a href="/contact">Contact</a></div></div></div><div id="_app_content-wrapper__HNwfi"><main id="_app_content__N_c_N"><div><h1>Using React with Web Components</h1><h4>7/2/2017</h4><div class="style_tags__twLQV"><span><a href="/blog?tag=javascript">javascript</a> </span><span><a href="/blog?tag=react">react</a> </span></div><p>Dealing with legacy code can be tough, even more so if you want to slowly migrate your front end to React.</p>
<p>Recently I found myself in a situation where some HTML was rendered server side, and inserted into the browser on request. I wanted to use a shiny new React component, instead of falling back to the legacy jQuery code.</p>
<p>In comes <a href="https://www.webcomponents.org">Web Components</a>!</p>
<p>Web Components allow you to write your own HTML tags, and use them through out your application. This solves my problem, by having the server render the new HTML tag, and the front end automatically load the required JavaScript to render/control it. When rendering the Web Component we can delegate the actual rendering to React.</p>
<p>Lets start with a simple React component:</p>
<pre><code class="language-JavaScript">import React from &quot;react&quot;;

class MyComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello world! This was rendered using React!&lt;/div&gt;;
  }
}
</code></pre>
<p>In order to render the component, we have to create a new HTMLElement as so:</p>
<pre><code class="language-JavaScript">class CustomHTMLElement extends HTMLElement {
  connectedCallback() {
    ReactDOM.render(&lt;MyComponent /&gt;, this);
  }
}
</code></pre>
<p>In this, when the component is loaded by the browser, the <code>connectedCallback</code> will be called, allowing us to render the new component, at <code>this</code> (the location of the element in the DOM).</p>
<p>To finish, we just have to register the element with the customElements API:</p>
<pre><code class="language-JavaScript">customElements.define(&quot;x-test&quot;, CustomHTMLElement);
</code></pre>
<p>Now we can just use the tag <code>&lt;x-test/&gt;</code> in our HTML, to render the React component!</p>
<p>One problem with this setup can be <a href="https://babeljs.io">Babel</a>, as it doesn&#x27;t play nice with transforming classes and extending <code>HTMLElement</code>.
We can work around this using a custom class, and extending the prototype of HTMLElement:</p>
<pre><code class="language-JavaScript">function BabelHTMLElement() {
  const newTarget = Object.getPrototypeOf(this).constructor;
  return Reflect.construct(HTMLElement, [], newTarget);
}

Object.setPrototypeOf(BabelHTMLElement.prototype, HTMLElement.prototype);

class CustomHTMLElement extends BabelHTMLElement {
    ...
</code></pre>
<p>Now our <code>CustomHTMLElement</code> extends the <code>BabelHTMLElement</code> rather the <code>HTMLElement</code> directly.</p>
<p>To view an example project with this in use, you can checkout the repo here: <a href="https://github.com/Amwam/react-webcomponents">https://github.com/Amwam/react-webcomponents</a></p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"POST":"Dealing with legacy code can be tough, even more so if you want to slowly migrate your front end to React.\n\nRecently I found myself in a situation where some HTML was rendered server side, and inserted into the browser on request. I wanted to use a shiny new React component, instead of falling back to the legacy jQuery code.\n\nIn comes [Web Components](https://www.webcomponents.org)!\n\nWeb Components allow you to write your own HTML tags, and use them through out your application. This solves my problem, by having the server render the new HTML tag, and the front end automatically load the required JavaScript to render/control it. When rendering the Web Component we can delegate the actual rendering to React.\n\nLets start with a simple React component:\n\n```JavaScript\nimport React from \"react\";\n\nclass MyComponent extends React.Component {\n  render() {\n    return \u003cdiv\u003eHello world! This was rendered using React!\u003c/div\u003e;\n  }\n}\n```\n\nIn order to render the component, we have to create a new HTMLElement as so:\n\n```JavaScript\nclass CustomHTMLElement extends HTMLElement {\n  connectedCallback() {\n    ReactDOM.render(\u003cMyComponent /\u003e, this);\n  }\n}\n```\n\nIn this, when the component is loaded by the browser, the `connectedCallback` will be called, allowing us to render the new component, at `this` (the location of the element in the DOM).\n\nTo finish, we just have to register the element with the customElements API:\n\n```JavaScript\ncustomElements.define(\"x-test\", CustomHTMLElement);\n```\n\nNow we can just use the tag `\u003cx-test/\u003e` in our HTML, to render the React component!\n\nOne problem with this setup can be [Babel](https://babeljs.io), as it doesn't play nice with transforming classes and extending `HTMLElement`.\nWe can work around this using a custom class, and extending the prototype of HTMLElement:\n\n```JavaScript\nfunction BabelHTMLElement() {\n  const newTarget = Object.getPrototypeOf(this).constructor;\n  return Reflect.construct(HTMLElement, [], newTarget);\n}\n\nObject.setPrototypeOf(BabelHTMLElement.prototype, HTMLElement.prototype);\n\nclass CustomHTMLElement extends BabelHTMLElement {\n    ...\n```\n\nNow our `CustomHTMLElement` extends the `BabelHTMLElement` rather the `HTMLElement` directly.\n\nTo view an example project with this in use, you can checkout the repo here: [https://github.com/Amwam/react-webcomponents](https://github.com/Amwam/react-webcomponents)\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"react-web-components"},"buildId":"KBWOP7REuQKajdISRRdU8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>